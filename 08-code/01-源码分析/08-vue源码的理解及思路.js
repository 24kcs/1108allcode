/**
 * 
 * Vue的理解,数据代理,模版解析,劫持,双向数据绑定?
 * 数据代理--->劫持--->模版解析
 * 
 * 
 * Vue中是有数据代理的
 *   创建Vue的实例对象的时候,把data对象中所有数据通过Object.keys()进行遍历,内部调用Object.defineProperty()把data对象中所有的数据一个一个添加到vm实例对象上,vm对象可以直接访问data对象中的数据了,vm代理了data,data是被代理者
 * Vue中是有数据劫持的
 *   当Vue中数据代理结束后,就开始数据劫持,通过observe()方法开始进行数据的劫持,判断data是一个对象后,创建劫持的实例对象,内部遍历vm的data对象,然后把vm的data对象中所有的数据一个一个添加到劫持对象的data对象上,当前在正式添加之前,创建dep对象(id,subs数组),只要vm中的data对象有多少个属性就会创建多少个dep对象(将来和watcher建立关系)
 * Vue中是有模版解析的
 *  当数据劫持后,开始模版解析,获取html中的容器对象,然后在内存中创建文档碎片对象,把容器中的所有的节点全部的添加到文档碎片对象中,然后遍历所有的节点,判断节点是标签还是文本?
 * 如果是标签,获取该标签内部的所有的属性,判断当前的属性是不是指令
 *  如果是事件指令,通过addEventLister()方法绑定事件
 *  如果是普通指令,调用compileUtil中相关方法,进入到updater对象中调用方法进行操作
 * 
 * 如果是文本,还要判断当前的文本节点是不是插值,如果是插值则调用updater对象中相关的方法,进行替换数据操作
 * 
 * 最终很多方法都会调用compileUtil中的方法,会进入到bind方法内部,开始创建watcher对象,会获取当前使用的表达式的值,会调用get方法,内部就开始建立dep和watcher的关系(调用了get方法,获取表达式的值,进入mvvm的get,会进入observer中的get方法,调用watcher对象中的addDep方法)
 * dep和watcher的关系
 * 1对1
 * 1对多
 * 多对1
 * 多对多
 * 把watcher添加到dep的subs数组,把dep连同id添加到watcher的depIds对象中
 * 
 * 此时,在内存中的文档碎片对象中模版解析已经全部搞定,最后全部的渲染到html容器中,显示到界面中
 * 如果页面中更新数据,会直接进入mvvm的set方法,进入obserber的set方法,找到当前修改数据的这个属性对应的dep对象,调用当前dep.notify()通知对应的这个dep的subs数组中的watcher对象,调用内部的update方法,判断数据是否需要进行修改,如果需要修改最后调用updater对象中的相关方法,进行模版的再次解析数据操作,界面变化了
 * 
 *    
 * 
 * Vue中是有双向数据绑的，同上
 创建Vue的实例的时候,除了数据绑定和数据劫持以外,会进入到compile模版解析中,在内存中创建文档碎片对象,把html容器中所有的子级节点全部的存放在文档碎片对象中,遍历所有的节点判断当前的节点是不是标签,然后获取当前节点标签中所有的属性,判断当前的属性是不是指令,然后再判断当前的指令是不是普通指令v-model,再然后为当前的节点标签绑定input事件
     * 如果标签中的数据发生变化,此时触发input事件,判断表达式之前的数据和现在输入的数据是否不同,之后会进入到MVVM的set方法内部再进入到observer.js的set方法内部,根据当前的这个属性的dep对象通知当前dep对象中subs数组中的watcher进行数据的更新操作
 * 
 * 
 * 
 */